name: CD - Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        options: [dev, prod]
      image_tag:
        type: string
        default: 'latest'
  workflow_run:
    workflows: ["CI - Build and Push Docker Images"]
    types: [completed]
    branches: [main]
  push:
    branches: [main]
    paths:
      - 'helm-chart/vote-app/**'
      - 'helm-chart/infrastructure/**'
      - 'helm-chart/postgresql/**'
      - 'helm-chart/redis/**'

permissions:
  id-token: write
  contents: read

jobs:
  check-cluster-ready:
    runs-on: ubuntu-latest
    # Only run if: manual trigger OR workflow_run succeeded OR helm chart push to main
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    environment: dev
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
      
      - name: Check if namespace exists
        id: check
        run: |
          aws eks update-kubeconfig --name tactful-voting-dev --region ${{ vars.AWS_REGION }}
          
          if kubectl get namespace voting-dev &>/dev/null; then
            # Check if data stores are ready
            if kubectl get statefulset postgresql -n voting-dev &>/dev/null && \
               kubectl get statefulset redis-master -n voting-dev &>/dev/null; then
              echo "ready=true" >> $GITHUB_OUTPUT
              echo "✅ Cluster is ready for deployment" >> $GITHUB_STEP_SUMMARY
            else
              echo "ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Namespace exists but data stores not ready. Run 'CD - Setup EKS Cluster' first" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "❌ Namespace voting-dev not found. Run 'CD - Setup EKS Cluster' first" >> $GITHUB_STEP_SUMMARY
          fi

  deploy-dev:
    needs: check-cluster-ready
    if: needs.check-cluster-ready.outputs.ready == 'true'
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
      - run: aws eks update-kubeconfig --name tactful-voting-dev --region ${{ vars.AWS_REGION }}
      - uses: azure/setup-helm@v4
      - id: tag
        run: |
          # Helper function to get the SHA tag that 'latest' points to
          get_latest_sha() {
            local image=$1
            # Get the digest of 'latest' tag
            local latest_digest=$(docker manifest inspect ibrahim1025/${image}:latest 2>/dev/null | jq -r '.manifests[0].digest' || echo "")
            
            if [ -z "$latest_digest" ]; then
              echo "latest" 
              return
            fi
            
            # Find which sha- tag has the same digest
            local sha_tag=$(curl -s "https://hub.docker.com/v2/repositories/ibrahim1025/${image}/tags?page_size=50" | \
              jq -r ".results[] | select(.name | startswith(\"sha-\")) | select(.digest == \"$latest_digest\") | .name" | head -1)
            
            if [ -n "$sha_tag" ]; then
              echo "$sha_tag"
            else
              echo "latest"  # fallback
            fi
          }
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual: use specified tag for all services
            echo "vote=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "result=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "worker=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ]; then
            # Helm chart change: use latest SHA tags for all services
            echo "vote=$(get_latest_sha \"vote\")" >> $GITHUB_OUTPUT
            echo "result=$(get_latest_sha \"result\")" >> $GITHUB_OUTPUT
            echo "worker=$(get_latest_sha \"worker\")" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Auto: Get SHA from triggering workflow
            SHORT_SHA=$(echo "${{ github.event.workflow_run.head_sha }}" | cut -c1-7)
            
            # Check which services changed - if new image exists, use it; otherwise get latest SHA tag
            if docker manifest inspect ibrahim1025/vote:sha-${SHORT_SHA} &>/dev/null; then
              VOTE_TAG="sha-${SHORT_SHA}"
            else
              VOTE_TAG=$(get_latest_sha "vote")
            fi
            
            if docker manifest inspect ibrahim1025/result:sha-${SHORT_SHA} &>/dev/null; then
              RESULT_TAG="sha-${SHORT_SHA}"
            else
              RESULT_TAG=$(get_latest_sha "result")
            fi
            
            if docker manifest inspect ibrahim1025/worker:sha-${SHORT_SHA} &>/dev/null; then
              WORKER_TAG="sha-${SHORT_SHA}"
            else
              WORKER_TAG=$(get_latest_sha "worker")
            fi
            
            echo "vote=$VOTE_TAG" >> $GITHUB_OUTPUT
            echo "result=$RESULT_TAG" >> $GITHUB_OUTPUT
            echo "worker=$WORKER_TAG" >> $GITHUB_OUTPUT
          else
            # Fallback: fetch SHA tags from Docker Hub for 'latest'
            echo "vote=$(get_latest_sha \"vote\")" >> $GITHUB_OUTPUT
            echo "result=$(get_latest_sha \"result\")" >> $GITHUB_OUTPUT
            echo "worker=$(get_latest_sha \"worker\")" >> $GITHUB_OUTPUT
          fi
      - run: |
          helm upgrade --install voting-app helm-chart/vote-app -n voting-dev \
            -f helm-chart/vote-app/values.yaml -f helm-chart/vote-app/values-dev.yaml \
            --set vote.image.tag=${{ steps.tag.outputs.vote }} \
            --set result.image.tag=${{ steps.tag.outputs.result }} \
            --set worker.image.tag=${{ steps.tag.outputs.worker }} \
            --wait --timeout 10m
      - run: kubectl wait --for=condition=available -n voting-dev deployment/vote deployment/result deployment/worker --timeout=5m
      
      - run: |
          echo "### ✅ Dev Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- Vote: \`${{ steps.tag.outputs.vote }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Result: \`${{ steps.tag.outputs.result }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Worker: \`${{ steps.tag.outputs.worker }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Vote URL:** \`kubectl get ingress vote-ingress -n voting-dev\`" >> $GITHUB_STEP_SUMMARY
          echo "**Result URL:** \`kubectl get ingress result-ingress -n voting-dev\`" >> $GITHUB_STEP_SUMMARY

  deploy-prod:
    runs-on: ubuntu-latest
    environment: prod
    if: github.event_name == 'workflow_dispatch' && inputs.environment == 'prod'
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      # Prod: Deploy via SSM
      - id: prod-tag
        run: echo "value=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
      - run: |
          INSTANCE_ID=${{ secrets.PROD_SSM_INSTANCE_ID }}
          
          # Upload Helm chart to S3
          aws s3 cp helm-chart/vote-app/ s3://tactful-voting-artifacts-${{ vars.AWS_REGION }}/helm-chart/vote-app/ --recursive
          
          # Execute deployment via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              'aws eks update-kubeconfig --name tactful-voting-prod --region ${{ vars.AWS_REGION }}',
              'aws s3 cp s3://tactful-voting-artifacts-${{ vars.AWS_REGION }}/helm-chart/vote-app/ /tmp/vote-app/ --recursive',
              'helm upgrade --install voting-app /tmp/vote-app -n voting-prod -f /tmp/vote-app/values.yaml -f /tmp/vote-app/values-prod.yaml --set vote.image.tag=${{ steps.prod-tag.outputs.value }} --set result.image.tag=${{ steps.prod-tag.outputs.value }} --set worker.image.tag=${{ steps.prod-tag.outputs.value }} --wait --timeout 15m',
              'kubectl wait --for=condition=available -n voting-prod deployment/vote deployment/result deployment/worker --timeout=10m || helm rollback voting-app -n voting-prod'
            ]" \
            --output text --query "Command.CommandId")
          
          # Wait and get output
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID"
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query "StandardOutputContent" --output text
          
          # Check if command succeeded
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query "Status" --output text)
          if [ "$STATUS" != "Success" ]; then
            echo "❌ Deployment failed"
            exit 1
          fi

  smoke-dev:
    needs: deploy-dev
    if: needs.deploy-dev.result == 'success'
    uses: ./.github/workflows/smoke-tests.yaml
    secrets: inherit
    with:
      environment: dev

  smoke-prod:
    needs: deploy-prod
    if: needs.deploy-prod.result == 'success'
    uses: ./.github/workflows/smoke-tests.yaml
    secrets: inherit
    with:
      environment: prod
